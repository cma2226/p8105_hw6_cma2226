---
title: "Homework 6"
author: "Caroline Andy"
date: "12/6/2020"
output: html_document
---

### Problem 1

```{r load, warning = FALSE, message = FALSE}
library(purrr)
library(tidyverse)
library(stringr)
library(patchwork)
library(skimr)
library(modelr)

knitr::opts_chunk$set(
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)
```

```{r}
#generate homicide table and summarize solved and unsolved murders by state
homicide = 
  read_csv("homicide-data.csv", na = c("", "NA", "Unknown")) %>%
  drop_na() %>%
  mutate(
    city_state = str_c(city, state, sep = ", "),
    victim_age = as.numeric(victim_age),
    victim_sex = as.factor(victim_sex),
    resolution = case_when(
      disposition %in% "Closed without arrest" ~ 0,
      disposition %in% "Closed by arrest" ~ 1, 
      disposition %in% "Open/No arrest" ~ 0)) %>%
  filter(
    victim_race %in% c("White", "Black"),
    !(city_state %in% c("Tulsa, AL", "Dallas, TX", "Phoenix, AZ", "Kansas City, MO"))) %>%
  mutate(
    victim_race = as.factor(victim_race),
    victim_race = as.character(victim_race),
    victim_sex = as.character(victim_sex)
  ) %>%
  select(city_state, resolution, victim_age, victim_race, victim_sex)

skim(homicide)
```

Start with one city.

```{r}
baltimore_df = 
  homicide %>%
  filter(city_state == "Baltimore, MD")

glm(resolution ~ victim_age + victim_race + victim_sex, 
    data = baltimore_df, 
    family = binomial()) %>%
  broom::tidy() %>%
  mutate(
    OR = exp(estimate),
    CI_lower = exp(estimate - 1.96 * std.error),
    CI_upper = exp(estimate + 1.96 * std.error)
  ) %>%
  select(term, OR, starts_with("CI")) %>%
  knitr::kable(digits = 3)
```

Try this across cities.

```{r}
model_results_df = 
  homicide %>%
  nest(data = -city_state) %>%
  mutate(
    models = 
      map(.x = data, ~glm(resolution ~ victim_age+victim_sex, data = .x, family = binomial())),
    results = map(models, broom::tidy)
) %>%
  select(city_state, results) %>%
  unnest(results) %>%
  mutate(
    OR = exp(estimate),
    CI_lower = exp(estimate - 1.96 * std.error),
    CI_upper = exp(estimate + 1.96 * std.error)
  ) %>%
  select(city_state, term, OR, starts_with("CI"))

summary(homicide)
```

```{r}
model_results_df %>%
  filter(term == "victim_sexMale") %>%
  mutate(city_state = fct_reorder(city_state, OR)) %>%
  ggplot(aes(x = city_state, y = OR)) +
  geom_point() +
  geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

### Problem 2

Make 3 models (2 specified, 1 that is our choice) and compare them. Can pick and choose variables to include in model (if we specify why). 

In this problem, I will analyze data gathered to understand the effects of several variables on a child’s birthweight. This dataset consists of roughly 4000 children and includes 20 variables, including baby sex, head circumference, length, gestational age, and mother's age, age at menarche, height, race and previous pregnancy outcomes. 

Here I will load and clean the data for regression analysis, converting numeric variables to factor variables where appropriate, and checking for missing values. 

```{r, message = FALSE, warning = FALSE}
bweight = read_csv("./birthweight.csv")
skim(bweight) 
# no missing values, all variables are numeric

# convert sex, race and malformation variable to factors
bweight = bweight %>%
  mutate(babysex = (fct_infreq(as.factor(babysex))),
         frace = (fct_infreq(as.factor(frace))),
         mrace = (fct_infreq(as.factor(mrace))),
         malform = (fct_infreq(as.factor(malform)))) 
```

Now I will propose a regression model for birthweight using backwards stepwise selection with the step() function. 

```{r, message = FALSE, warning = FALSE}
## function for backward stepwise selection
mult.fit <- lm(bwt ~ ., data = bweight)
step(mult.fit, direction = 'backward')

## final proposed model based on backward stepwise selection: 
reg = lm(bwt ~ babysex + bhead + blength + delwt + fincome + gaweeks + 
    mheight + mrace + parity + ppwt + smoken, data = bweight)

reg %>% 
  broom::tidy() %>% 
  select(term, estimate, p.value) %>% 
  knitr::kable(digits = 3)
```

Describe your modeling process and show a plot of model residuals against fitted values – use add_predictions and add_residuals in making this plot.

We can graph residuals against x values to see if there are any trends in residuals (ie. low x values tend to have higher residuals, etc).

```{r, message = FALSE, warning = FALSE}
bweight = modelr::add_residuals(bweight, reg)
modelr::add_predictions(bweight, reg) %>%
  ggplot(aes(x = pred, y = resid)) + geom_point()
```

While most values are centered around a residual value of 0 and predicted value between 2500 and 3500, we can see in the above plot that lower predicted values tend to have higher residual values. 

Now I will compare this model to two other models: (1) a simple model containing only baby length and gestational week as predictors, and (2) a model containing baby length, head circumference, sex, and the three-way interactions of these variables. 

```{r, message = FALSE, warning = FALSE}
## Predictors = length and gesitational age 
length_gest = lm(bwt ~ blength + gaweeks, data = bweight)
length_gest %>%
  broom::glance()
summary(length_gest)
## Adjusted R squared = 0.5767

## Predictors = head circumference, length, sex and all interactions
length_circ_sex = lm(bwt ~ blength*bhead*babysex, data = bweight)
length_circ_sex %>%
  broom::glance()
summary(length_circ_sex)
## Adjusted R squared = 0.6844 
```

```{r, message = FALSE, warning = FALSE}
cv_df = 
  crossv_mc(bweight, 4342) 
train = cv_df %>% pull(train) %>% .[[1]] %>% as_tibble
test = cv_df %>% pull(test) %>% .[[1]] %>% as_tibble

cv_df =
  cv_df %>% 
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble))

cv_df = 
  cv_df %>% 
  mutate(
    length_ga_mod  = map(train, ~lm(bwt ~ blength + gaweeks, data = .x)),
    length_circ_sex_mod = map(train, ~lm(bwt ~ blength*bhead*babysex, data = .x)), 
    my_mod  = map(train, ~lm(bwt ~ babysex + bhead + blength + delwt + fincome + gaweeks + 
    mheight + mrace + parity + ppwt + smoken, data = .x))) %>% 
  mutate(
    rmse_simple = map2_dbl(length_ga_mod, test, ~rmse(model = .x, data = .y)),
    rmse_interaction = map2_dbl(length_circ_sex_mod, test, ~rmse(model = .x, data = .y)),
    rmse_backward_step = map2_dbl(my_mod, test, ~rmse(model = .x, data = .y)))
```

```{r, message = FALSE, warning = FALSE}
cv_df %>% 
  select(starts_with("rmse")) %>% 
  pivot_longer(
    everything(),
    names_to = "model", 
    values_to = "rmse",
    names_prefix = "rmse_") %>% 
  mutate(model = fct_inorder(model)) %>% 
  ggplot(aes(x = model, y = rmse)) + geom_violin()
```

Lowest RMSE is preferred. 

### Problem 3

```{r message = FALSE, warning = FALSE}
weather_df = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2017-01-01",
    date_max = "2017-12-31") %>%
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY"),
    tmin = tmin / 10,
    tmax = tmax / 10) %>%
  select(name, id, everything())

# regression model for 1 (weather_df) sample
lm(tmax ~ tmin, data = weather_df) %>% 
  broom::tidy() %>% 
  knitr::kable(digits = 3)
```

```{r, message = FALSE, warning = FALSE}
# draw one bootstrap sample
set.seed(1)

boot_sample = function(df) {
  sample_frac(weather_df, replace = TRUE)
}

# draw 5000 bootstrap samples
boot_straps = 
  data_frame(
    strap_number = 1:5000,
    strap_sample = rerun(5000, boot_sample(weather_df))
  )

# running regression models using 5000 bootstrap samples 
bootstrap_results = 
  boot_straps %>% 
  mutate(
    models = map(strap_sample, ~lm(tmax ~ tmin, data = .x) ),
    results1 = map(models, broom::glance),
    results2 = map(models, broom::tidy)) %>% 
  select(strap_number, results1, results2) %>% 
  unnest(results1, results2) 

# find mean r squared
bootstrap_results %>%
  summarize(mean_r_sq = mean(r.squared))

# generate log(B0*B1) variable
btstrap_log_data = 
  bootstrap_results %>%
  select(strap_number, term, estimate) %>%
  pivot_wider(
    names_from = term,
    values_from = estimate) %>%
  rename("B0" = "(Intercept)",
         "B1" = "tmin") %>%
  mutate(
    log_var = log(B0*B1)
  )
```

```{r, message = FALSE, warning = FALSE}
bootstrap_results %>%
  ggplot(aes(x = r.squared)) +
  geom_density(alpha = .4, adjust = .5, color = "blue")
```

```{r, message = FALSE, warning = FALSE}
btstrap_log_data %>%
  ggplot(aes(x = log_var)) +
  geom_density(alpha = .4, adjust = .5, color = "blue")
```

Using the 5000 bootstrap estimates, identify the 2.5% and 97.5% quantiles to provide a 95% confidence interval for r̂ 2 and log(β̂ 0∗β̂ 1).

```{r, message = FALSE, warning = FALSE}
## r^2 95% CI
bootstrap_results %>% 
  summarize(
    ci_lower = quantile(r.squared, 0.025), 
    ci_upper = quantile(r.squared, 0.975))

btstrap_log_data %>% 
  summarize(
    ci_lower = quantile(log_var, 0.025), 
    ci_upper = quantile(log_var, 0.975))
```

Normal, r^2 is maybe skewed left? 